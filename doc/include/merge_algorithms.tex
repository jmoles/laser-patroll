\linespread{1}
\begin{algorithm*}[t]
\caption{Merge Algorithm}\label{merge}
\begin{algorithmic}
\Require A,B are sorted arrays
\Require length(dst) = length(A) + length(B)

\Procedure{Merge}{$dst, A, B$}
\State $i, j, k\gets0$ \Comment initialize array indicies
\While{(\emph{i within bounds of A) \textbf{and} (j within bounds of B})} 
	\State $dst[k] \gets \textsc{min}(A[i], B[j]$)
		\State \textit{Increment index of array containing min element (i or j)}	
		\State \textit{Increment k}
\EndWhile
\While{(\emph{i within bounds of A)}} \Comment i still in bounds
	\State $dst[k] \gets A[i]$
	\State \textit{Increment i}
\EndWhile

\While{(\emph{j within bounds of j)}} \Comment j still in bounds
	\State $dst[k] \gets A[j]$
	\State \textit{Increment j}
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm*}

\begin{algorithm*}[t]
\caption{MergeSort Algorithm}\label{mergesort}
\begin{algorithmic}[1]
\Require dst and src are arrays of equal length
\Require low and high are indices into A

\Procedure{MergeSort}{$dst, src, low, high$}

\If {$(low < high)$}
\State \emph {pivot} $\gets$ $\textsc{floor}(low+high)/2$
\State \textsc{MergeSort}$(SortedLeft, A, low, pivot )$\Comment sort left half
\State \textsc{MergeSort}$(SortedRight, A, pivot+1, high)$ \Comment sort right half
\State \textsc{Merge}$(dst,SortedLeft, SortedRight)$\Comment merge left \& right

\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm*}

\begin{algorithm*}[t]
\caption{Multithreaded Mergesort (MMS)}\label{mms}
\begin{algorithmic}[1]
\Require dst and src are arrays of equal length
\Require low and high are indices into src

\Procedure{MMS}{$dst, src, low, high, threads\_remaining$}


	\If{$threads\_remaining == 0$} \Comment perform basic MergeSort
		\State [perform basic MergeSort algorithm] 
	
	\Else \Comment a new thread will be spawned to sort left
	\If {$(low < high)$}
\State \emph {pivot} $\gets$ $\textsc{floor}(low+high)/2$
	\State \emph{t\_left} = $\textsc{Floor}((threads\_remaining-1)/2)$
	\State \emph{t\_right = t\_left}$ + ((threads\_remaining-1)\%2)$
	\State \emph{New\_Thread}$\gets\emph{\textsc{MMS}(SortedLeft,A,low,pivot, t\_left)}$
	\State \emph{\textsc{MMS}$(SortedRight,A,pivot+1, high, t\_right)$}
	\State \emph{\textsc{Wait}(New\_Thread)}
	\State \emph{\textsc{Merge}$(dst,SortedLeft,SortedRight)$}
\EndIf
\EndIf

\EndProcedure
\end{algorithmic}
\end{algorithm*}
